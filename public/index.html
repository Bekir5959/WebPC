<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebPC</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
    html, body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at center,#000 0%,#030303 60%,#0a0a0a 100%);
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      font-family: 'Inter', sans-serif; /* Inter fontu */
    }
    canvas {
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      image-rendering: pixelated; /* Pikselleşmeyi koru */
      cursor: crosshair; /* Fare imleci */
      outline: none; /* Odaklandığında oluşan çerçeveyi kaldır */
      border-radius: 8px; /* Köşeleri yuvarla */
      box-shadow: 0 4px 15px rgba(0, 255, 0, 0.5); /* Yeşil gölge */
    }

    /* Kontrol paneli */
    #hud {
      position: fixed;
      top: 16px;
      left: 16px;
      background: rgba(0,0,0,0.6);
      color: #0f0;
      padding: 8px 12px;
      font-size: 12px;
      border-radius: 6px;
      font-family: 'Inter', sans-serif;
      pointer-events: none;
      user-select: none;
    }

    #toolbar {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
    }

    .btn {
      background: rgba(0,0,0,0.7);
      color: #0f0;
      border: 1px solid #0f0;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-size: 13px;
    }
    .btn:hover { background: rgba(0,255,0,0.1); }
    .btn:active { background: rgba(0,255,0,0.2); }

    /* Queue status panel */
    #queueStatus {
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(0,0,0,0.8);
      color: #0f0;
      padding: 12px 16px;
      border-radius: 8px;
      font-family: 'Inter', sans-serif;
      font-size: 13px;
      min-width: 200px;
      border: 1px solid #0f0;
    }

    #queueStatus.hidden {
      display: none;
    }

    .queue-item {
      margin: 4px 0;
      padding: 4px 0;
      border-bottom: 1px solid rgba(0,255,0,0.2);
    }

    .queue-item:last-child {
      border-bottom: none;
    }

    .time-remaining {
      color: #ff6b6b;
      font-weight: 600;
    }

    .queue-position {
      color: #4ecdc4;
      font-weight: 600;
    }

    .current-controller {
      background: rgba(0,255,0,0.1);
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 8px;
    }

    .estimated-wait {
      color: #feca57;
      font-size: 11px;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <canvas id="screen" tabindex="0"></canvas>

  <!-- Heads-Up Display -->
  <div id="hud">FPS: <span id="fps">0</span></div>

  <!-- Queue Status Panel -->
  <div id="queueStatus" class="hidden">
    <div id="currentControllerInfo"></div>
    <div id="queueInfo"></div>
    <div id="userQueueInfo"></div>
    <div id="queueList"></div>
  </div>

  <!-- Toolbar -->
  <div id="toolbar">
    <button id="btnFullscreen" class="btn">Tam Ekran</button>
  </div>

  <div id="loginOverlay" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.8);z-index:1000;">
    <form id="loginForm" style="background:#111;padding:24px 32px;border:1px solid #0f0;border-radius:8px;display:flex;flex-direction:column;gap:12px;font-family:'Inter',sans-serif;">
      <h2 style="color:#0f0;margin:0;font-weight:600;font-size:18px;text-align:center;">Kullanıcı Adı</h2>
      <input id="txtUsername" type="text" placeholder="örn. ali" maxlength="16" required style="padding:8px 10px;border-radius:4px;border:1px solid #0f0;background:#000;color:#0f0;font-size:14px;" />
      <button class="btn" type="submit" style="align-self:center;width:100px;">Giriş</button>
      <span id="loginError" style="color:#f66;font-size:12px;display:none;">Bu kullanıcı adı kullanılıyor</span>
    </form>
  </div>

  <script src="https://unpkg.com/simple-peer/simplepeer.min.js"></script>
  <script>
    const canvas = document.getElementById('screen');
    // 2D bağlamını al, alpha: false ile daha iyi performans (opak çizimler için)
    const ctx = canvas.getContext('2d', { alpha: false });
    canvas.focus(); // Klavye olaylarını yakalamak için canvas'a odaklan

    // Canvas'a tıklandığında focus al
    canvas.addEventListener('mousedown', () => {
      canvas.focus();
    });

    // Görüntü işleme için Web Worker
    // Bu worker, ana iş parçacığını engellemeden JPEG verilerini işler, bu da performansı artırır.
    const workerCode = `
      self.onmessage = async ({ data }) => {
        const { x, y, jpegData } = data;
        try {
          // JPEG verisini Blob'a dönüştür ve createImageBitmap ile bitmap oluştur
          const blob = new Blob([jpegData], { type: 'image/jpeg' });
          const bitmap = await createImageBitmap(blob);
          // Bitmap'i ve konum bilgilerini ana iş parçacığına geri gönder
          self.postMessage({ bitmap, x, y, width: bitmap.width, height: bitmap.height }, [bitmap]);
        } catch (e) {
          self.postMessage({ error: e.message }); // Hata durumunda hata mesajını gönder
        }
      };
    `;
    // Worker kodunu Blob olarak oluştur ve URL'sini al
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));

    const frameQueue = []; // İşlenecek karelerin kuyruğu
    let isFirstFrame = true; // İlk kare mi kontrolü

    // Worker'dan gelen mesajları işle
    worker.onmessage = ({ data }) => {
      if (data.error) {
        console.error("Worker hatası:", data.error);
        return;
      }
      frameQueue.push(data); // Gelen kare verisini kuyruğa ekle
    };

    // Kareleri çizen döngü
    // requestAnimationFrame kullanarak tarayıcının ekran yenileme hızına senkronize olur
    function renderLoop() {
      const now = performance.now();
      while (frameQueue.length > 0) {
        const { bitmap, x, y, width, height } = frameQueue.shift(); // Kuyruktan kare al
        if (bitmap) {
          // İlk kare ise ve tam ekran güncellemesi ise canvas boyutunu ayarla
          if (isFirstFrame && x === 0 && y === 0) {
            if (canvas.width !== width || canvas.height !== height) {
              canvas.width = width;
              canvas.height = height;
              console.log(`Canvas ayarlandı: ${width}x${height}`);
            }
            isFirstFrame = false;
          }
          ctx.drawImage(bitmap, x, y); // Bitmap'i canvas'a çiz
          bitmap.close(); // Bitmap kaynağını serbest bırak
        }
      }
      // FPS hesapla
      frameCount++;
      if (now - fpsLastTime >= 1000) {
        document.getElementById('fps').textContent = frameCount;
        frameCount = 0;
        fpsLastTime = now;
      }
      requestAnimationFrame(renderLoop); // Bir sonraki kare için tekrar çağır
    }
    let frameCount = 0, fpsLastTime = performance.now();
    renderLoop(); // Render döngüsünü başlat

    let ws=null, peer=null, currentUsername=''; // bağlantılar
    let hasControl = false;
    let queuePosition = null;
    let timeRemaining = null;
    let estimatedWaitTime = null;
    let controllerUsername = null;
    let queueUsernames = [];
    let queueLength = 0;
    let countdownTimer = null;
    let lastTimeUpdate = null;
    let controlTimeLimit = 15; // default, will be updated from backend

    function connect(username){
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

      ws.onopen = () => {
        ws.send(JSON.stringify({type:'login', username }));
      };

      ws.onmessage = e => {
        const msg = JSON.parse(e.data);
        if(msg.type==='login'){
          if(msg.ok){
            document.getElementById('loginOverlay').style.display='none';
            startPeer();
            updateQueueStatus();
          }else{
            document.getElementById('loginError').style.display='block';
            ws.close();
          }
          return;
        }
        if(msg.type==='signal' && peer && !peer.destroyed){
          peer.signal(msg.data);
        }
        if(msg.type==='control'){
          handleControlMessage(msg);
        }
        if(msg.type==='controller'){
          handleControllerMessage(msg);
        }
        if(msg.type==='queueUpdate'){
          handleQueueUpdate(msg);
        }
      };

      ws.onerror=console.error;
      ws.onclose=()=>{ if(peer&&!peer.destroyed) peer.destroy(); };

      function startPeer(){
        peer=new SimplePeer({initiator:true,trickle:true});

        peer.on('signal',data=>{ if(ws.readyState===WebSocket.OPEN) ws.send(JSON.stringify({type:'signal',data})); });
        peer.on('connect',()=>console.log('WebRTC bağlantı hazır'));
        peer.on('data',handlePeerData);
        peer.on('close',()=>{isFirstFrame=true;frameQueue.length=0;});
      }
    }

    function handlePeerData(data){
      const view=new DataView(data.buffer);const x=view.getUint32(0);const y=view.getUint32(4);const jpegData=data.slice(8);
      worker.postMessage({x,y,jpegData},[jpegData.buffer]);
    }

    function handleControlMessage(msg){
      if(msg.granted){
        hasControl=true;
        document.getElementById('btnControl').textContent='Kontrolü Bırak';
        queuePosition = null;
        if (msg.timeLimit) controlTimeLimit = Math.floor(msg.timeLimit / 1000);
        updateQueueStatus();
      } else if(msg.queued){
        document.getElementById('btnControl').textContent='Kuyrukta';
        queuePosition = msg.queuePosition;
        estimatedWaitTime = msg.estimatedWaitTime;
        updateQueueStatus();
      } else if(msg.expired){
        hasControl=false;
        document.getElementById('btnControl').textContent='Kontrolü Al';
        updateQueueStatus();
      }
    }

    function handleControllerMessage(msg){
      controllerUsername = msg.username;
      timeRemaining = msg.timeRemaining;
      queueUsernames = msg.queue || [];
      queueLength = msg.queueLength || (queueUsernames ? queueUsernames.length : 0);
      lastTimeUpdate = Date.now();
      if (msg.timeLimit) controlTimeLimit = Math.floor(msg.timeLimit / 1000);
      startCountdown();
      updateQueueStatus();
    }

    function handleQueueUpdate(msg){
      queuePosition = msg.queuePosition;
      estimatedWaitTime = msg.estimatedWaitTime;
      queueUsernames = msg.queue || [];
      queueLength = msg.queueLength || (queueUsernames ? queueUsernames.length : 0);
      updateQueueStatus();
    }

    function startCountdown() {
      if (countdownTimer) clearInterval(countdownTimer);
      countdownTimer = setInterval(() => {
        if (typeof timeRemaining === 'number' && timeRemaining > 0 && lastTimeUpdate) {
          const elapsed = Math.floor((Date.now() - lastTimeUpdate) / 1000);
          const displayTime = Math.max(0, timeRemaining - elapsed);
          updateQueueStatus(displayTime);
        }
      }, 1000);
    }

    function updateQueueStatus(liveTime){
      const queueStatus = document.getElementById('queueStatus');
      const currentControllerInfo = document.getElementById('currentControllerInfo');
      const queueInfo = document.getElementById('queueInfo');
      const userQueueInfo = document.getElementById('userQueueInfo');
      const queueList = document.getElementById('queueList');

      // Show/hide panel based on whether there's any queue activity
      const hasQueueActivity = queuePosition !== null || hasControl || timeRemaining !== null;
      queueStatus.classList.toggle('hidden', !hasQueueActivity);

      if (!hasQueueActivity) return;

      // Current controller info
      let displayTime = typeof liveTime === 'number' ? liveTime : timeRemaining;
      if (hasControl) {
        currentControllerInfo.innerHTML = `
          <div class="current-controller">
            <strong>🎮 Siz kontrol ediyorsunuz</strong><br>
            <span class="time-remaining">Kalan süre: ${displayTime || controlTimeLimit} saniye</span>
          </div>
        `;
      } else if (controllerUsername) {
        currentControllerInfo.innerHTML = `
          <div class="current-controller">
            <strong>🎮 ${controllerUsername === currentUsername ? 'Siz' : controllerUsername} kontrol ediyor</strong><br>
            <span class="time-remaining">Kalan süre: ${displayTime || controlTimeLimit} saniye</span>
          </div>
        `;
      } else {
        currentControllerInfo.innerHTML = '';
      }

      // User's queue position and live estimated wait time
      let myQueueIndex = -1;
      if (queueUsernames && currentUsername) {
        myQueueIndex = queueUsernames.findIndex(u => u === currentUsername);
      }
      let liveEstimatedWait = null;
      if (myQueueIndex !== -1) {
        // myQueueIndex: 0 means first in queue, 1 means second, etc.
        liveEstimatedWait = (displayTime || 0) + controlTimeLimit * myQueueIndex;
      }
      if (queuePosition !== null) {
        userQueueInfo.innerHTML = `
          <div class="queue-item">
            <strong>📋 Kuyruk Pozisyonunuz: ${queuePosition}</strong><br>
            <span class="estimated-wait">Tahmini bekleme süresi: ${liveEstimatedWait !== null ? liveEstimatedWait : estimatedWaitTime} saniye</span>
          </div>
        `;
      } else {
        userQueueInfo.innerHTML = '';
      }

      // General queue info
      if (queueLength > 0) {
        queueInfo.innerHTML = `
          <div class="queue-item">
            <strong>👥 Toplam kuyruk: ${queueLength} kişi</strong>
          </div>
        `;
      } else {
        queueInfo.innerHTML = '';
      }

      // Show full queue list
      if (queueUsernames && queueUsernames.length > 0) {
        queueList.innerHTML = `<div class="queue-item"><strong>Kuyruktakiler:</strong><br>${queueUsernames.map((u, i) => `<span>${i + 1}. ${u}</span>`).join('<br>')}</div>`;
      } else {
        queueList.innerHTML = '';
      }
    }

    document.getElementById('loginForm').addEventListener('submit',e=>{
      e.preventDefault();
      const uname=document.getElementById('txtUsername').value.trim();
      if(uname){currentUsername=uname;connect(uname);}
    });

    // --- Mouse & Klavye Girişini Gönderme ---

    // Sunucuya giriş olaylarını gönderen yardımcı fonksiyon
    function sendInput(type, payload) {
      if (ws.readyState === WebSocket.OPEN && hasControl) {
        ws.send(JSON.stringify({ type: 'input', inputType: type, payload }));
      }
    }

    // Canvas üzerindeki fare koordinatlarını hesapla
    function getCanvasCoord(e) {
      const rect = canvas.getBoundingClientRect();
      // Canvas'ın gerçek boyutuna göre ölçekleme yap
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = Math.floor((e.clientX - rect.left) * scaleX);
      const y = Math.floor((e.clientY - rect.top) * scaleY);
      return { x, y };
    }

    let currentMouseButtonMask = 0; // Basılı olan fare tuşlarının bit maskesi
    let lastMouseMoveTime = 0;
    let mouseMoveThrottleDelay = 16; // ~60fps için throttling
    let lastClickTime = 0;
    let lastClickButton = -1;
    let doubleClickDelay = 500; // 500ms içinde ikinci tıklama = çift tıklama

    // Throttled mouse move handler
    function throttledMouseMove(e) {
      const now = performance.now();
      if (now - lastMouseMoveTime < mouseMoveThrottleDelay) return;

      lastMouseMoveTime = now;
      const { x, y } = getCanvasCoord(e);
      // Fare hareket ederken basılı olan tuşların maskesini gönder (sürükleme için önemli)
      sendInput('mouseMove', { x, y, buttonMask: currentMouseButtonMask });
    }

    // Fare hareketi (throttled)
    canvas.addEventListener('mousemove', throttledMouseMove);

    // Fare tuşu basılı
    canvas.addEventListener('mousedown', e => {
      const { x, y } = getCanvasCoord(e);
      // Basılan tuşun maskesini mevcut maskeye ekle
      currentMouseButtonMask |= (1 << e.button);
      // Güncellenmiş maskeyi VNC sunucusuna gönder
      sendInput('mouseDown', { x, y, buttonMask: currentMouseButtonMask });
    });

    // Fare tuşu bırakıldı
    canvas.addEventListener('mouseup', e => {
      const { x, y } = getCanvasCoord(e);
      // Bırakılan tuşun maskesini mevcut maskeden çıkar
      currentMouseButtonMask &= ~(1 << e.button);
      // Güncellenmiş maskeyi VNC sunucusuna gönder
      sendInput('mouseUp', { x, y, buttonMask: currentMouseButtonMask });
    });

    // Çift tıklama desteği
    canvas.addEventListener('dblclick', e => {
      e.preventDefault();
      const { x, y } = getCanvasCoord(e);

      // Çift tıklama simülasyonu: hızlı mousedown -> mouseup -> mousedown -> mouseup
      const buttonMask = (1 << e.button);

      setTimeout(() => {
        sendInput('mouseDown', { x, y, buttonMask: buttonMask });
        setTimeout(() => {
          sendInput('mouseUp', { x, y, buttonMask: 0 });
          setTimeout(() => {
            sendInput('mouseDown', { x, y, buttonMask: buttonMask });
            setTimeout(() => {
              sendInput('mouseUp', { x, y, buttonMask: 0 });
            }, 50);
          }, 50);
        }, 50);
      }, 10);
    });

    // Sağ tıklama ile tarayıcı bağlam menüsünün açılmasını engelle
    canvas.addEventListener('contextmenu', e => {
      e.preventDefault(); // Tarayıcının varsayılan bağlam menüsünü engelle
    });

    // --- Klavye Haritalaması ve Olayları ---

    // Türkçe Q klavye düzeni için gelişmiş keymap
    // Modifier tuşları takip etmek için state
    let modifierState = {
      shift: false,
      altgr: false,
      ctrl: false,
      alt: false
    };

    // JavaScript event.code'dan evdev koduna mapping
    const CODE_TO_EVDEV = {
      "Escape": 1, "Digit1": 2, "Digit2": 3, "Digit3": 4, "Digit4": 5, "Digit5": 6,
      "Digit6": 7, "Digit7": 8, "Digit8": 9, "Digit9": 10, "Digit0": 11,
      "Minus": 12, "Equal": 13, "Backspace": 14, "Tab": 15,
      "KeyQ": 16, "KeyW": 17, "KeyE": 18, "KeyR": 19, "KeyT": 20, "KeyY": 21,
      "KeyU": 22, "KeyI": 23, "KeyO": 24, "KeyP": 25, "BracketLeft": 26, "BracketRight": 27,
      "Enter": 28, "ControlLeft": 29, "KeyA": 30, "KeyS": 31, "KeyD": 32, "KeyF": 33,
      "KeyG": 34, "KeyH": 35, "KeyJ": 36, "KeyK": 37, "KeyL": 38, "Semicolon": 39,
      "Quote": 40, "Backquote": 41, "ShiftLeft": 42, "Backslash": 43,
      "KeyZ": 44, "KeyX": 45, "KeyC": 46, "KeyV": 47, "KeyB": 48, "KeyN": 49,
      "KeyM": 50, "Comma": 51, "Period": 52, "Slash": 53, "ShiftRight": 54,
      "NumpadMultiply": 55, "AltLeft": 56, "Space": 57, "CapsLock": 58,
      "F1": 59, "F2": 60, "F3": 61, "F4": 62, "F5": 63, "F6": 64, "F7": 65, "F8": 66,
      "F9": 67, "F10": 68, "NumLock": 69, "ScrollLock": 70,
      "AltRight": 100, "ControlRight": 97
    };

    // Türkçe Q klavye düzeni (keymap-trq.json'dan alınmış)
    const TRQ_KEYMAP = {
      1: {base: 0xff1b}, // Escape
      2: {base: 0x0031, shift: 0x0021, altgr: 0x003e}, // 1 ! >
      3: {base: 0x0032, shift: 0x0027, altgr: 0x00a3}, // 2 ' £
      4: {base: 0x0033, shift: 0x005e, altgr: 0x0023}, // 3 ^ #
      5: {base: 0x0034, shift: 0x002b, altgr: 0x0024}, // 4 + $
      6: {base: 0x0035, shift: 0x0025, altgr: 0x00bd}, // 5 % ½
      7: {base: 0x0036, shift: 0x0026, altgr: 0x00be}, // 6 & ¾
      8: {base: 0x0037, shift: 0x002f, altgr: 0x007b}, // 7 / {
      9: {base: 0x0038, shift: 0x0028, altgr: 0x005b}, // 8 ( [
      10: {base: 0x0039, shift: 0x0029, altgr: 0x005d}, // 9 ) ]
      11: {base: 0x0030, shift: 0x003d, altgr: 0x007d}, // 0 = }
      12: {base: 0x002a, shift: 0x003f, altgr: 0x005c}, // * ? \
      13: {base: 0x002d, shift: 0x005f, altgr: 0x007c}, // - _ |
      14: {base: 0xff08}, // Backspace
      15: {base: 0xff09}, // Tab
      16: {base: 0x0071, shift: 0x0051, altgr: 0x0040}, // q Q @
      17: {base: 0x0077, shift: 0x0057}, // w W
      18: {base: 0x0065, shift: 0x0045, altgr: 0x20ac}, // e E €
      19: {base: 0x0072, shift: 0x0052, altgr: 0x00b6}, // r R ¶
      20: {base: 0x0074, shift: 0x0054, altgr: 0x20ba}, // t T ₺
      21: {base: 0x0079, shift: 0x0059, altgr: 0x2190}, // y Y ←
      22: {base: 0x0075, shift: 0x0055, altgr: 0x00fb}, // u U û
      23: {base: 0x01000131, shift: 0x0049, altgr: 0x010000ee}, // ı I î (Unicode keysym)
      24: {base: 0x006f, shift: 0x004f, altgr: 0x010000f4}, // o O ô
      25: {base: 0x0070, shift: 0x0050}, // p P
      26: {base: 0x0100011f, shift: 0x0100011e, altgr: 0x00a8}, // ğ Ğ ¨ (Unicode keysym)
      27: {base: 0x010000fc, shift: 0x010000dc, altgr: 0x007e}, // ü Ü ~ (Unicode keysym)
      28: {base: 0xff0d}, // Enter
      29: {base: 0xffe3}, // Control_L
      30: {base: 0x0061, shift: 0x0041, altgr: 0x00e2}, // a A â
      31: {base: 0x0073, shift: 0x0053, altgr: 0x00a7}, // s S §
      32: {base: 0x0064, shift: 0x0044}, // d D
      33: {base: 0x0066, shift: 0x0046, altgr: 0x00aa}, // f F ª
      34: {base: 0x0067, shift: 0x0047}, // g G
      35: {base: 0x0068, shift: 0x0048}, // h H
      36: {base: 0x006a, shift: 0x004a}, // j J
      37: {base: 0x006b, shift: 0x004b}, // k K
      38: {base: 0x006c, shift: 0x004c}, // l L
      39: {base: 0x0100015f, shift: 0x0100015e, altgr: 0x00b4}, // ş Ş ´ (Unicode keysym)
      40: {base: 0x0069, shift: 0x01000130, altgr: 0x0027}, // i İ ' (Unicode keysym)
      41: {base: 0x0022, shift: 0x00e9, altgr: 0x003c}, // " é <
      42: {base: 0xffe1}, // Shift_L
      43: {base: 0x002c, shift: 0x003b, altgr: 0x0060}, // , ; `
      44: {base: 0x007a, shift: 0x005a, altgr: 0x00ab}, // z Z «
      45: {base: 0x0078, shift: 0x0058, altgr: 0x00bb}, // x X »
      46: {base: 0x0063, shift: 0x0043, altgr: 0x00a2}, // c C ¢
      47: {base: 0x0076, shift: 0x0056, altgr: 0x201c}, // v V "
      48: {base: 0x0062, shift: 0x0042, altgr: 0x201d}, // b B "
      49: {base: 0x006e, shift: 0x004e}, // n N
      50: {base: 0x006d, shift: 0x004d, altgr: 0x00b5}, // m M µ
      51: {base: 0x010000f6, shift: 0x010000d6, altgr: 0x00d7}, // ö Ö × (Unicode keysym)
      52: {base: 0x010000e7, shift: 0x010000c7, altgr: 0x00b7}, // ç Ç · (Unicode keysym)
      53: {base: 0x002e, shift: 0x003a}, // . :
      54: {base: 0xffe2}, // Shift_R
      55: {base: 0xffaa}, // NumpadMultiply
      56: {base: 0xffe9}, // Alt_L
      57: {base: 0x0020}, // Space
      58: {base: 0xffe5}, // CapsLock
      59: {base: 0xffbe}, // F1
      60: {base: 0xffbf}, // F2
      61: {base: 0xffc0}, // F3
      62: {base: 0xffc1}, // F4
      63: {base: 0xffc2}, // F5
      64: {base: 0xffc3}, // F6
      65: {base: 0xffc4}, // F7
      66: {base: 0xffc5}, // F8
      67: {base: 0xffc6}, // F9
      68: {base: 0xffc7}, // F10
      69: {base: 0xff7f}, // NumLock
      70: {base: 0xff14}, // ScrollLock
      97: {base: 0xffe4}, // Control_R
      100: {base: 0xffea} // Alt_R (AltGr)
    };

    // Keysym hesaplama fonksiyonu
    function getKeysym(evdevCode) {
      const keyDef = TRQ_KEYMAP[evdevCode];
      if (!keyDef) return null;

      // Modifier kombinasyonlarına göre keysym seç
      if (modifierState.shift && modifierState.altgr && keyDef.shift_altgr) {
        return keyDef.shift_altgr;
      } else if (modifierState.altgr && keyDef.altgr) {
        return keyDef.altgr;
      } else if (modifierState.shift && keyDef.shift) {
        return keyDef.shift;
      } else {
        return keyDef.base;
      }
    }

    // Klavye tuşuna basıldığında
    canvas.addEventListener('keydown', e => {
      e.preventDefault(); // Tarayıcının varsayılan davranışını engelle (kısayollar için önemli)

      const evdevCode = CODE_TO_EVDEV[e.code];
      if (!evdevCode) {
        console.warn(`Bilinmeyen tuş kodu: ${e.code}`);
        return;
      }

      // Modifier tuşları güncelle
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
        modifierState.shift = true;
      } else if (e.code === 'AltRight') { // AltGr
        modifierState.altgr = true;
      } else if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
        modifierState.ctrl = true;
      } else if (e.code === 'AltLeft') {
        modifierState.alt = true;
      }

      const keysym = getKeysym(evdevCode);
      if (keysym !== null) {
        // Debug: hangi keysym gönderildiğini göster
        console.log(`Key down: ${e.code} -> evdev:${evdevCode} -> keysym:0x${keysym.toString(16)} (${String.fromCharCode(keysym & 0xFFFF)})`);
        // Tuşun basılı olduğunu sunucuya bildir
        sendInput('keyEvent', { keysym: keysym, down: true });
      } else {
        console.warn(`Keysym bulunamadı: ${e.code} (evdev: ${evdevCode})`);
      }
    });

    // Klavye tuşu bırakıldığında
    canvas.addEventListener('keyup', e => {
      e.preventDefault(); // Tarayıcının varsayılan davranışını engelle

      const evdevCode = CODE_TO_EVDEV[e.code];
      if (!evdevCode) {
        console.warn(`Bilinmeyen tuş kodu (keyup): ${e.code}`);
        return;
      }

      // Modifier tuşları güncelle
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
        modifierState.shift = false;
      } else if (e.code === 'AltRight') { // AltGr
        modifierState.altgr = false;
      } else if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
        modifierState.ctrl = false;
      } else if (e.code === 'AltLeft') {
        modifierState.alt = false;
      }

      const keysym = getKeysym(evdevCode);
      if (keysym !== null) {
        // Tuşun bırakıldığını sunucuya bildir
        sendInput('keyEvent', { keysym: keysym, down: false });
      } else {
        console.warn(`Keysym bulunamadı (keyup): ${e.code} (evdev: ${evdevCode})`);
      }
    });

    document.getElementById('btnFullscreen').addEventListener('click', () => {
      if (!document.fullscreenElement) {
        canvas.requestFullscreen().catch(console.error);
      } else {
        document.exitFullscreen();
      }
    });

    // Kontrolü almak için canvas'a tıkla (çift tıklama ile çakışmayı önlemek için delay)
    let clickTimeout = null;
    canvas.addEventListener('click', (e) => {
      if (!ws) return;

      // Çift tıklama durumunda click event'ini iptal et
      if (clickTimeout) {
        clearTimeout(clickTimeout);
        clickTimeout = null;
        return;
      }

      clickTimeout = setTimeout(() => {
        if (!hasControl) {
          ws.send(JSON.stringify({type:'control',action:'request'}));
        }
        clickTimeout = null;
      }, 250); // 250ms bekle, çift tıklama gelirse iptal et
    });
  </script>
</body>
</html>
